#!/usr/bin/envruby
require'hipe-core/struct/table'
require'hipe-core/interfacey'
require'open3'
require'ostruct'
require'ruby-debug'


classHipe::FileMetrics2
includeHipe::Interfacey::Service
interface.mightdo

speaks:cli

describe<<-desc
filemetrics-viewstatisticsaboutdistributionoflinesofcode
astheyaredistributedaccrossatreeoffiles
desc

default_request"help"

responds_to("lc").desc<<-desc
showsthelinecountofeachfile,longestfirst.Show
percentagesofmaxforeachfile.willgorecursively
intodirectories.

desc

responds_to("lc")do

opts.on('-n','--nameNAME',:many=>true).
desc<<-desc
e.g.--name='*.rb'.Whenpresent,thislimitsthe
filesanalyzedtotheoneswhosebasenamematches
thispattern.Itcanbespecifiedmultipletimesto
addmultiplefilenamepatterns,whichwillbroaden
thesearch.Youshouldusequotestoavoid
shellexpansion.")

WhenPATHisafile,thisoptionisignored.

desc


opts.on('-e','--exclude-dirDIR',:many=>true,:default=>'.*').
desc<<-desc
folderswhosebasenamematchthispatternwillnotbe
descendedinto.Itcanbespecifiedmultipletimes
withmultiplepatternstonarrowthesearch.
Ifnotprovided,thedefaultistoskipfolderswhose
namestartswitha'.'(period).Toincludesuch
dirs,specify"--exclude-dirs=[]"thefirsttimeyou
usethisoptioninthecommand.(ithastheeffect
ofclearingthe"blacklist"ofdirectoriestoskip)

desc


opts.on('--find',
'justshowthegeneratedfindcommandwewouldhaveused.')

opts.on('--list',
'justlisttheresultingfilesthatmatchthequery.')

#opts.on('-e','--[no-]table',:default=>'yes').desc<<-desc
#whetherornottorendertheresultsinanasciitable,
#withatitleheaderandcolumnsheaders.(default:yes)
#desc


opts.on('-h','--help','thisscreen',&help)

required('path',"thefileordirectorytosearch.")

end

cmd=responds_to("dirs")

cmd.desc<<-desc
experimentalreport.allfoldersonelevelunder<path>,
foreachofthemreportnumberoffilesandtotalsloc,
andshowtheminorderoftotalslocandpercentofmax
desc

cmd.definedo
opts.on('-n','--namePATTERN','multiplenamespatterns',:many=>true)
opts.on('-e','--exclude-dirDIR',:many=>true,:default=>'.*').
desc<<-desc
folderstoskip.defaultsto'.*'
desc
opts.on('--find','onlyshowfindcommand')
opts.on('--list','onlylistmatchedfolders')
opts.on('-h',&help)
required('path')
end

responds_to"help","thispage",:aliases=>['-h','--help','-?']
end

deflcpath,opts
returnbuild_find_files_command(path,opts)ifopts.find
filepaths=find_all_paths([path],opts)orreturnerror
returnfilepaths*"\n"ifopts.list
branch=linecount_branch_node_one_level('files',filepaths)or
returnerror
branch.sort_by!{|node|node.stats.ratio_of_max}
table=Hipe::Table.makedo
label%|summaryoflinecountsfor#{branch.name}|
field(:line_count){|node|sprintf('%8d',node.stats.count)}
field(:percent){|node|node.stats.percent_of_max('%5.01f%')}
field(:filename){|node|node.name}
listbranch.list||[]
end
table.render(:ascii)
end

deffind_all_pathspaths,opts
result=[]
paths.eachdo|path|
ifFile.directory?path
result|=(find_files(path,opts)orreturnerror)
else
result<<pathunlessresult.include?path
end
end
result
end

deffind_filespath,opts
find_cmd=build_find_files_command(path,opts)
run_find_commandfind_cmdorreturnerror
end

defbuild_find_files_commandpath,opts
%{find#{path}#{files_query(opts)}}
end

defrun_find_commandcmd
system_linescmd
end

#@todomakethismorerobust
defsystem_linescmd
sin,sout,serr=Open3.popen3cmd
out,err=[sout.read.strip,serr.read.strip]
returnerror(%|errorrunningsystemcommand:"#{err}"|)unlesserr==""
out.split("\n")
end

deffiles_queryopts
ands=[]
ifopts.exclude_dir.size>0
dirnames=opts.exclude_dir.map{|x|%{-name'#{x}'}}*'-o'
ands.push'-not\(-typed\(-mindepth1-a'+dirnames+
'\)-prune\)-not-typed'
end
ifopts.name
ands.push'\('+opts.name.map{|x|%{-name'#{x}'}}*'-o'+'\)'
end
ands*'-a'
end


deflinecount_branch_node_one_levellabel,files
#ifsortisnotavailableonthesystem,considerdoingitw/ruby
returnHipe::DataNode::Branch.newiffiles.size==0
lines=system_lines(%{wc-l#{files*''}|sort-g})orreturnerror
caselines.size
when0:returnerror("notexpectingzerolinesfromwc")
when1:
md=/^(\d+)(.+)$/.match(lines.last)or
returnerror(%|regexfailagainstwcresults:"#{lines.last}"|)
wc_total=md[1]
else
md=/^*(\d+)total$/.match(x=lines.pop)or
returnerror(%|regexfailagainstwcresults:"#{x}"|)
wc_total=md[1].to_i
end
lines.map!do|wordcount_line|
match_data=wordcount_line.match(%r{(\d+)\s+(.+)$})orreturn("fail")
Hipe::DataNode::Leaf.newdo|me|
me.count=match_data[1].to_i
me.name=match_data[2]
end
end
branch=Hipe::DataNode::Branch.new()do|b|
b.name=label;
b.list=lines
end
Hipe::Stats[branch]
end


defbuild_find_dirs_commandpath,opts
ands=[]
ifopts.exclude_dir.size>0
dirnames=opts.exclude_dir.map{|x|%{-name'#{x}'}}*'-o'
ands.push'-not\(-typed\(-mindepth1-a'+dirnames+
'\)-prune\)'
end
ands.push'-maxdepth1-typed'
qry=ands*'-a'
%|find#{path}#{qry}|
end

defdirspath,opts
file_exists(path)orreturnerror
find_command=build_find_dirs_command(path,opts)
returnfind_commandifopts.find
files=system_lines(find_command)orreturnerror
return(files*"\n")ifopts.list
do_dirspath,files,opts
end

deffile_existspath
File.exist?(path)?true:error("filedoesnotexist:#{path}")
end

defdo_dirspath,folders,opts
root_list=folders.mapdo|folder|
list=find_files(folder,opts)orreturnerror
linecount_branch_node_one_level(
File.basename(folder),list
)orreturnerror
end
root=Hipe::DataNode::Branch.newdo|me|
me.name="folderssummary"
me.list=root_list
end
Hipe::Stats[root]

root.sort_by!do|child|
child.stats.count
end

table=Hipe::Table.makedo
label%|summaryoffoldersin#{path}|
field(:folder_name){|x|x.name}
field(:total_lines){|x|x.stats.count}
field(:percent_of_max){|x|x.stats.percent_of_max('%5.01f')}
field(:number_of_files){|x|x.list.length}
field(:longest_file){|x|x.stats.max}
listroot.list
end

table.render(:ascii)
end

#@oldschoolsetter-getter.usethistoreturnfalseandamessage
#fromsubroutines.usethisalsotogetthelastsetmessageasa
#responseobjectsuitableforreturningfrominteface-levelcommands
deferror(msg=nil)
ifmsg.nil?
msg=@last_error_msg||'unknownerror!'
Hipe::Interfacey::ResponseLite.new(:error=>msg)
else
re=/^([^:]+):(\d+)(?::in`([^']+)')?$/
if(md=caller(1)[0].match(re))
msg<<%|(near#{File.basename(md[1])}line#{md[2]})|
#@todothisisn'twhatwewantbutwhy?
end
@last_error_msg=msg
false
end
end
end

moduleHipe::Stats

#
#EnhanceaDataNode::Branch-likewithstatisticsaboutitsnodes
#
#ObjectsthatextendStatsshouldrespondto"count"or"list",those
#thosethatrespondto"list"shouldyieldobjectsthatrespondto"count"
#or"list"...andsoon.
#
#(originallyjumpedthroughalotofhoopssothatwecould
#determinethepercentileratingofthenumberoflinesofeachfile
#amongthesetoffiles,
#(includingre-writingapure-rubybinarysearchtree,)
#thenrealizedafterfinishingitthatapercentileratingof
#eachitemamongagroupofitemswillalwayshavealineardistribution,
#makingtheresultsuninteresting.)
#
#


#commonpattern
defself.[]obj;obj.extendself;objend
defself.extendedobj;obj.init_statsend

definit_stats
class<<self
attr_reader:stats
end
@stats||=Calculator.newself
end

classStatsError<RuntimeError;end

classStatsCache#wasopenstructbut...
attr_accessor:count,:max_node
end

classCalculator

#
#Astatscalculatorobjectholdsahandletoadatanodeand
#calculatesandcachesstatisticaloperationsonthenode.
#

attr_accessor:parent
definitializenode
raise"whereisnode"unlessnode
err=Hipe::ShapeAssert.fails(node)do|it|
to_be_a"calculatablenode"
required_thatit.respond_to?(:name)
required_thatit.respond_to?(:count)||it.respond_to?(:list)
end
raiseStatsError.new(err.message)iferr

@node=node
@cache=StatsCache.new
if@node.respond_to?:listand@node.list&&@node.list.size
@node.list.eachdo|child|
Hipe::Stats[child]
child.stats.parent=self
end
end
end
defcount
@cache.count||=begin
if@node.respond_to?:count
@node.count
elsif@node.respond_to?:list
@node.list.map{|child|child.stats.count}.reduce(:+)
else
raiseStatsError.new(%|can'tdeterminecountfor"#{@node.name}"|)
end
end
@cache.count||0
end
defmax_node
@cache.max_node||=begin
if@node.respond_to?:list
returnnilif@node.list.size==0
@node.list.injectdo|longest,current|
longest.stats.max>current.stats.max?longest:current
end
@node
elsif@node.respond_to?:count
@node
else
raiseStatsError.new(
%|can'tdeterminemaxnodefor"#{@node.name}"|)
end
end
end
defmax
max_node?max_node.stats.count:0#@todo
end
defratio_of_max
raiseStatsError.new(%|can'tcalculateratioofmax|<<
%|onnodeswithoutparents|)unlessparent
result=count.to_f/parent.max.to_f
result
end
defpercent_of_max(fmt)
ratio=ratio_of_max
percent=ratio*100
sprintf(fmt,percent)
end
end#Calculator

#
#maplinenumberstotheirpercentilerating(s),arraymustbesorted
#theresultingarraywillhavethepercentileasanindex,contiguous
#integersfromzerotothelargestpercentileyourequestedin
#which_percentiles.Thevalueofthearrayelementswillbenilforthe
#percentilesnotpresentwhich_percentiles
#
#defcalculate_percentiles(which_percentiles=(0..99).to_a)
##which_percentiles=(0..99).to_a#[0,25,50,75,99]#
#raise"pleasedon'taskfor100orabovepercentilerating"if
#which_percentiles.last>=100
#result={}
#which_percentiles.eachdo|percentile|
#result[percentile]=data[
#((percentile.to_f/100)*data.length).floor
#][attribute]
#end
#btree=Hipe::SimpleBTree.new()
#btree.write_mode_on
#result.eachdo|percent,count|
#btree[count]||=[]
#btree[count]<<percent
#end
#btree.write_mode_off
##wemighthavemultiplepercentilesforsinglelinecountvalues,
##inwhichcasewewanttomakeapercentilerange.Inotherwordswe
##arelosslesslyinvertingthehash
#btree.each.eachdo|pair|
#btree[pair[0]]=(pair[1].min..pair[1].max)
#end
#@btree=btree
#end
#
#defpercentile_rangecount
#if@btree[count]
#@btree[count]
#else
#above=@btree.lower_boundcount
#below=@btree.upper_boundcount
#my_lo=below?below[1].end:0
#my_hi=above?above[1].begin:99
#my_lo..my_hi
#end
#end



end#Stats

moduleHipe::DataNode
#
#datanodesareslightlyenhancedstructsofsomesort.
#theyshouldnothavealotofheavymethodimplementations,
#theyjustholddata
#
moduleSemiReadableConstuctor
definitialize*args,&block
super(*args)
yieldself
end
end
classBranch
attr_accessor:name,:list
definitialize&block
@list=[]
@name=''
yieldselfifblock_given?
end
deflist=list
@list=list||[]
end
defsort_by!(&block)
list.sort!do|x,y|
left=block.call(x)
rite=block.call(y)
(left==rite)?0:(left>rite?-1:1)
end
end
end
classLeaf<Struct.new(:name,:count);
includeSemiReadableConstuctor
end
end#DataNode

moduleHipe::ShapeAssert
#
#attemptatareallylightweightstructural/interfaceassertionthing
#inspiredbybacon
#
classShapeAssertFail<RuntimeError;end
classMakeDefinitionFail<ShapeAssertFail;end
classMatchDefinitionFail<ShapeAssertFail;end

#
#raisesMatchDefinitionFailifthethingdoesn'tmatchthedescription
#raisesMakeDefinitionFailifthereissomethingwrongwiththedefinition
#@returnnil
#
defself.againstthing,&block
iffail=fails(thing,&block)
raisefail
else
nil
end
end

defself.failsthing,&block
defin=Definition.new
proxy=RecordingProxy.newthing
fail=catch(:fail)do
defin.instance_exec(proxy,&block)
nil
end
iffail
rec=proxy.recordings.last
meth=rec[0]
args=rec.slice(1,rec.size).map{|x|x.inspect}*','
msg=%|tobea#{defin.desc}itmust#{meth}(#{args})|
returnMatchDefinitionFail.newmsg
end
returnnil
end

classDefinition
attr_reader:desc
defto_be_adesc
raiseMakeDefinitionFail.new(
%|let'ssticktostringsnot#{desc.inspect}fordescriptions|
)unlessdesc.kind_of?String
raiseMakeDefinitionFail.new(
%|won'tclobberexistingdescription'|
)if@desc
@desc=desc
end
defrequired_thatmixed
throw(:fail,'fail')unlessmixed
end
end

classRecordingProxy
#
#pass(almost)everymessagealongtotarget,butrecordeachone.
#wemighteventuallymakerecordingproxiesforcallslike.class()
#
keep_these=['__send__','__id__','debugger']
(instance_methods-keep_these).eachdo|name|
undef_methodname.to_sym
end
attr_accessor:recordings,:target
definitializemixed
@target=mixed
@recordings=[]
end
defmethod_missingname,*args
@recordings.push[name,*args]
@target.send(name,*args)
end
end
end


putsHipe::FileMetrics2.new.cli_run(ARGV)
